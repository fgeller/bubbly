#
# This file describes a data model to load into bubbly,
# also known as the bubbly schema. A database schema is 
# generated from bubbly schema by bubbly. In this specific
# case, the schema is a set of sometimes unrelated tables,
# which are then used by different Go tests and .bubbly scripts.
# It's more convenient to have everything in one place than
# to have to manage a multitude of individual schema files.
#

table "product" {
    field "name" {
        type = string
        unique = true
    }
}

table "project" {
    field "name" {
        type = string
        unique = true
    }

    join "product" { unique = true }
}

table "repo" {
    field "name" {
        type = string
        unique = true
    }

    table "branch" {
        // A branch is unique by the repo that it belongs to
        unique = true

        field "name" {
            type = string
            unique = true
        }
    }
    // A specific commit/version in a git repository
    table "commit" {
        // A commit is unique by the branch that it belongs to
        unique = true

        field "id" {
            type = string
            unique = true
        }
        field "tag" {
            type = string
        }
        // Would be really cool to store the time of a commit, and then we can
        // track how long it takes to do things, e.g. time to deploy
        field "time" {
            type = string
        }

        join "branch" {}
    }

    join "project" { unique = true }
}

table "artifact" {
    // The name of the artifact
    field "name" {
        type = string
    }
    // The sha256 of an artifact shall uniquely identify it
    field "sha256" {
        type = string
        unique = true
    }
    // A url, or path to a docker image. Should always start with a type, e.g.
    // https:// or docker:// or file://
    field "location" {
        type = string
    }
}

// #############################
// RELEASE
// #############################

table "release" {
    // TODO: what other fields should a release have?
    field "name" {
        type = string
        unique = true
    }
    field "version" {
        type = string
        unique = true
    }

    join "project" {
        unique = true
    }
    join "product" {
        unique = true
    }
}

// release_item is used to represent what we are releasing in a single release
// and can be of different types: git, artifact or release.
// Based on the type it should have a join to one of those tables
table "release_item" {

    // type should be one of git (commit), artifact or release
    field "type" {
        type = string
    }

    // Join to release. A release can have one or more release_items.
    // A release_item can belong to only one release, because it can have
    // crtieria associated with it, which are specific to a release
    join "release" {
        unique = true
    }

    // Join to the different item tables with a one-to-one relationship.
    // Only at most and at least one of these joins should exist, based on the
    // "type" field
    join "commit" {
        single = true
        unique = true
    }
    join "artifact" {
        single = true
        unique = true
    }
    // TODO: this is a problem because this creates a second join from release_item
    // to release... It could be solved by adding an alias
    // join "release" {
    //     alias = "item_release"
    //     single = true
    //     unique = true
    // }
}

// release_entry is used to record/log an event performed on a release_item,
// such as running of unit tests, or the creation of an artifact.
// release_entry is created by running a criteria and should contain the output
// from the running of that event
table "release_entry" {
    field "name" {
        type = string
        unique = true
    }
    field "result" {
        type = bool
    }

    // TODO: what other fields do we want to store? Probably something saying
    // *why* the criteria failed (a reason) and also perhaps the GraphQL
    // query used so that we could fetch the data? E.g.
    // field "query" { type = string}
    // field "reason" { type = string}

    // Join on release_item because every entry is associated with exactly one
    // release_item (git commit or artifact (or release?))
    join "release_item" { 
        unique = true
    }

    // Join on the _resource criteria that created this entry
    // release_entry
    join "_resource" { }
}

table "release_stage" {
    field "name" {
        type = string
        unique = true
    }

    join "release" { 
        unique = true
    }
}

table "release_criteria" {
    field "entry_name" {
        type = string
        unique = true
    }

    join "release_item" {
        unique = true
    }

    join "release_stage" {
        unique = true
    }
}

// #############################
// CODE_ISSUE
// #############################

table "code_issue" {
    join "commit" {}
    field "name" {
        type = string
    }
    field "severity" {
        type = string
    }
    field "type" {
        type = string
    }
}

// #############################
// TEST_RUN
// #############################

table "test_run" {
    field "name" {
        type = string
        unique = true
    }
    field "description" {
        type = string
    }
    field "elapsed" {
        type = number
    }
    table "test_set" {
        field "name" {
            type = string
        }
        field "description" {
            type = string
        }
        table "test_case" {
            field "name" {
                type = string
            }
            field "status" {
                type = string
            }
            table "step" {
                field "name" {
                    type = string
                }
                join "step" {}
            }
            table "failure" {
                field "type" {
                    type = string
                }
                field "message" {
                    type = string
                }
            }
        }
    }

    join "commit" { unique = true }
}

// #############################
// OSS
// #############################

#
# For integration/testdata/resources/v1/extract/licenses/licenses.bubbly
#
table "spdx_license" {
    field "id" {
        type = string
        unique = true
    }
    field "name" {
        type = string
    }
    field "crossref_count" {
        type = number
    }
}


// #############################
// GITHUB METRICS
// #############################
#
# For integration/testdata/resources/v1/extract/graphql/github.bubbly
#
table "repo_stats" {

    # TODO: would introducing multi-column `unique` constraints add value?
    # The value of tuple (owner, repo) is unique
    field "owner" {
        type = string
    }
    field "repo" {
        type = string
    }

    field "fork_count" {
        type = number
    }
    field "stargazer_count" {
        type = number
    }
    field "watcher_count" {
        type = number
    }
    field "open_issues_count" {
        type = number
    }
    field "closed_issues_count" {
        type = number
    }
    field "releases_count" {
        type = number
    }
    field "download_count" {
        type = number
    }

    table "issues" {
        field "title" {
            type = string
        }
        field "url" {
            type   = string
            unique = true
        }
        field "state" {
            type = string
        }
    }
}

#
# For integration/testdata/resources/v1/extract/graphql/tempo.bubbly
#
table "tempo_periods" {
    field "from_date" {
        type = string
        unique = true
    }
    field "to_date" {
        type = string
        unique = true
    }

    table "tempo_timesheet_approvals" {
        field "url" {
            type = string
            unique = true
        }
        field "required_seconds" {
            type = number
        }
        field "spent_seconds" {
            type = number
        }
        field "spent_less_required_seconds" {
            type = number
        }
    }
}

#
# For integration/testdata/snyk/snyk-pipeline.bubbly
#
table "snyk_vulnerabilities" {
    field "id" {
        type = string
    }
    field "name" {
        type = string
    }
    field "creationTime" {
        type = string
    }
    field "cvssScore" {
        type = string
    }
    field "language" {
        type = string
    }
    field "severity" {
        type = string
    }
    field "version" {
        type = string
    }
    field "cve" {
        type = string
    }
}

#
# For integration/testdata/gosec/gosec.bubbly
#
table "gosec_issues" {
    field "details" {
        type = string
    }
    field "rule_id" {
        type = string
    }
    field "severity" {
        type = string
    }
    field "line" {
        type = string
    }
    field "code_column" {
        type = string
    }
    field "file" {
        type = string
    }
    field "code" {
        type = string
    }
}